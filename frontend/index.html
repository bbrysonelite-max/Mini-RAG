<!doctype html>
<html>
<head>
<meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>RAG Desk</title>
<link rel="icon" type="image/svg+xml" href="/app/favicon.svg"/>
<style>
body{font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;margin:0;background:#f4f6f8;color:#111;line-height:1.6}
.app-layout{display:flex;min-height:100vh;background:#f4f6f8}
.sidebar{width:260px;padding:2rem 1.75rem;background:#fff;border-right:1px solid #e5e7eb;display:flex;flex-direction:column;gap:2rem;position:sticky;top:0;max-height:100vh;box-sizing:border-box}
.brand{font-size:1.5rem;font-weight:700;color:#111}
.workspace-switcher{display:flex;flex-direction:column;gap:.5rem}
.workspace-switcher label{font-size:.85rem;color:#475569;font-weight:600;text-transform:uppercase;letter-spacing:.04em}
.workspace-switcher select{padding:.55rem .75rem;border-radius:10px;border:1px solid #d0d7e2;background:#fafafa;font-size:.95rem;font-family:inherit}
.workspace-switcher select:focus{outline:none;border-color:#111;box-shadow:0 0 0 2px rgba(0,0,0,0.08);background:#fff}
.side-nav{display:flex;flex-direction:column;gap:.35rem}
.side-nav a{padding:.55rem .85rem;border-radius:10px;text-decoration:none;border:1px solid transparent;color:#333;font-weight:500;display:flex;align-items:center;gap:.6rem}
.side-nav a.active{background:#111;color:#fff;border-color:#111}
.side-nav a:not(.active):hover{border-color:#333;color:#111}
.sidebar-footer{margin-top:auto;font-size:.8rem;color:#64748b}
.app-shell{flex:1;max-width:100%;padding:2rem 3rem;box-sizing:border-box}
.app-header{display:flex;justify-content:space-between;align-items:flex-start;gap:1.5rem;margin-bottom:1.5rem;flex-wrap:wrap}
.page-heading{display:flex;flex-direction:column;gap:.5rem}
.page-heading h1{margin:0;font-size:1.9rem;font-weight:700;color:#111}
.workspace-pill{display:inline-flex;align-items:center;gap:.4rem;font-size:.85rem;padding:.25rem .65rem;border-radius:999px;background:#eef2ff;color:#312e81}
.user-meta{display:flex;align-items:center;gap:.75rem}
#breadcrumb{font-size:.9rem;color:#64748b}
#breadcrumb span{margin-right:.35rem}
#breadcrumb span::after{content:"/";margin-left:.35rem;color:#cbd5f5}
#breadcrumb span:last-child{color:#111;font-weight:600}
#breadcrumb span:last-child::after{content:""}
section{display:none;background:#fff;padding:1.5rem;border-radius:16px;box-shadow:0 10px 30px rgba(15,23,42,.08);margin-bottom:1.5rem}
section.active{display:block;animation:fadeIn .3s}
@keyframes fadeIn{from{opacity:0;transform:translateY(10px)}to{opacity:1;transform:translateY(0)}}
textarea,input[type=text]{width:100%;padding:.6rem;border:1px solid #ddd;border-radius:10px;font-family:inherit;font-size:inherit;box-sizing:border-box;background:#fafafa}
textarea:focus,input[type=text]:focus{outline:none;border-color:#111;box-shadow:0 0 0 2px rgba(0,0,0,0.1);background:#fff}
.btn{padding:.6rem 1rem;border-radius:10px;border:1px solid #333;background:#111;color:#fff;cursor:pointer;font-size:inherit;transition:all 0.2s;font-weight:500}
.btn:hover{background:#333;transform:translateY(-1px);box-shadow:0 2px 6px rgba(0,0,0,0.2)}
.btn:disabled{opacity:0.5;cursor:not-allowed;transform:none;box-shadow:none}
.btn:focus-visible{outline:3px solid rgba(59,130,246,0.6);outline-offset:3px}
a:focus-visible{outline:3px solid rgba(59,130,246,0.6);outline-offset:3px;border-radius:6px}
pre{background:#f7f7f7;padding:1rem;border-radius:12px;white-space:pre-wrap;max-height:420px;overflow:auto;border:1px solid #eee}
.badge{background:#eef2ff;border-radius:999px;padding:.2rem .6rem;margin-right:.4rem;font-size:0.85em;display:inline-block;color:#1e1b4b}
.small{font-size:.9em;color:#555}
.row{display:flex;gap:1rem;align-items:center;flex-wrap:wrap}
.counter{font-weight:600}
.source-card,.chunk-card{transition:all 0.2s}
.source-card:hover,.chunk-card:hover{box-shadow:0 4px 16px rgba(15,23,42,0.08);transform:translateY(-2px)}
mark{background:#fef08a;padding:0 2px;border-radius:4px}
a{color:#0d67ff;text-decoration:none}
a:hover{text-decoration:underline}
#toast{position:fixed;bottom:1.5rem;right:1.5rem;padding:1rem 1.25rem;border-radius:12px;background:#111;color:#fff;box-shadow:0 10px 25px rgba(0,0,0,0.15);display:none;z-index:2000}
#toast.error{background:#b42318}
#toast.success{background:#0f9d58}
.empty-state{padding:1rem;border:1px dashed #cbd5f5;border-radius:12px;background:#f8fafc;color:#475569;text-align:center}
@media (max-width:992px){
  .app-layout{flex-direction:column}
  .sidebar{position:static;width:auto;max-height:none;border-right:none;border-bottom:1px solid #e5e7eb;padding:1.5rem;gap:1.25rem}
  .side-nav{flex-direction:row;flex-wrap:wrap}
  .side-nav a{flex:1;justify-content:center}
  .app-shell{padding:1.5rem}
  .app-header{align-items:stretch}
}
@media (max-width:768px){
  .app-shell{padding:1.25rem}
  .btn,.row,.app-header{width:100%}
  .row{flex-direction:column;align-items:stretch}
  pre{max-height:300px}
}
</style>
</head>
<body>
<div class="app-layout">
  <aside class="sidebar">
    <div>
      <div class="brand">Mini-RAG</div>
      <p class="small" style="margin:0;color:#475569">Answer questions from your private sources.</p>
    </div>
    <div class="workspace-switcher">
      <label for="workspaceSelect">Workspace</label>
      <select id="workspaceSelect" aria-describedby="workspaceHint">
        <option value="default">Default workspace</option>
      </select>
      <span id="workspaceHint" class="small" style="color:#65738a">Switching updates query & ingest scope.</span>
    </div>
    <nav class="side-nav" aria-label="Primary navigation">
      <a href="#ask" data-nav="ask" class="active">üß† Ask</a>
      <a href="#browser" data-nav="browser">üìö Sources</a>
      <a href="#ingest" data-nav="ingest">‚¨ÜÔ∏è Ingest</a>
      <a href="#admin" data-nav="admin">‚öôÔ∏è Admin</a>
    </nav>
    <div class="sidebar-footer">Need help? Check the Quick Reference guide in docs.</div>
  </aside>
  <main class="app-shell" id="mainContent" tabindex="-1">
    <header class="app-header">
      <div class="page-heading">
        <h1 id="pageTitle">Ask</h1>
        <div class="workspace-pill">Workspace: <span id="workspaceLabel">Default workspace</span></div>
        <nav id="breadcrumb" aria-label="Breadcrumb">
          <span>Home</span><span>Ask</span>
        </nav>
      </div>
      <div class="user-meta">
        <div id="userInfo" style="display:none;align-items:center;gap:0.5rem">
          <div style="font-size:0.95rem" id="userName"></div>
          <button id="logoutBtn" class="btn" type="button" style="background:#c33">Log out</button>
        </div>
        <button id="loginBtn" class="btn" type="button">Sign in with Google</button>
      </div>
    </header>

    <div id="dashboardSummary" style="margin-bottom:1.5rem">
      <div style="display:grid;gap:1rem;grid-template-columns:repeat(auto-fit,minmax(220px,1fr));">
        <div style="background:#fff;padding:1.25rem;border-radius:14px;box-shadow:0 8px 24px rgba(15,23,42,0.08)">
          <div class="small" style="text-transform:uppercase;color:#64748b;font-weight:600;letter-spacing:.04em">Documents indexed</div>
          <div style="font-size:2rem;font-weight:700;margin-top:.35rem" id="metricDocCount">‚Äì</div>
          <div class="small" style="color:#94a3b8;margin-top:.25rem">Across the active workspace</div>
        </div>
        <div style="background:#fff;padding:1.25rem;border-radius:14px;box-shadow:0 8px 24px rgba(15,23,42,0.08)">
          <div class="small" style="text-transform:uppercase;color:#64748b;font-weight:600;letter-spacing:.04em">Last ingestion</div>
          <div style="font-size:1.25rem;font-weight:600;margin-top:.35rem" id="metricLastIngest">No ingests yet</div>
          <div class="small" style="color:#94a3b8;margin-top:.25rem" id="metricLastIngestDetail">Run ingest to populate your knowledge base.</div>
        </div>
        <div style="background:#fff;padding:1.25rem;border-radius:14px;box-shadow:0 8px 24px rgba(15,23,42,0.08)" id="billingCard">
          <div class="small" style="text-transform:uppercase;color:#64748b;font-weight:600;letter-spacing:.04em">Billing status</div>
          <div style="font-size:1.25rem;font-weight:600;margin-top:.35rem" id="metricBillingStatus">Unknown</div>
          <div class="small" style="color:#94a3b8;margin-top:.25rem" id="metricBillingDetail">Sign in with admin access to view Stripe status.</div>
        </div>
      </div>
    </div>

<section id="ask" class="active">
  <div class="row">
    <button id="mic" class="btn">üé§ Start listening</button>
    <span class="small">Current chunks: <span id="count" class="counter">‚Äì</span></span>
  </div>
  <textarea id="q" placeholder="Ask about your videos and guides..."></textarea>
  <button id="askBtn" class="btn">Ask</button>
  <h3>Answer</h3>
  <pre id="ans"></pre>
  <div id="score"></div>
  <div id="chunksSection" style="margin-top:2rem;display:none">
    <h3>Retrieved Chunks <span class="small" id="chunksCount"></span></h3>
    <div id="chunksList"></div>
  </div>
</section>

<section id="browser">
  <div class="row">
    <input type="text" id="sourceFilter" placeholder="Filter by name, type, or content..." style="flex:1;max-width:400px"/>
    <button id="refreshSources" class="btn">Refresh</button>
  </div>
  <div id="sourcesList"></div>
</section>

<section id="ingest">
  <h3>Ingest URLs</h3>
  <textarea id="urls" placeholder="Paste YouTube links, one per line"></textarea>
  <div class="row">
    <button id="ingestUrls" class="btn" type="button">Ingest URLs</button>
    <button id="retryUrlsBtn" class="btn" type="button" style="display:none;background:#0f766e">Retry failed URLs</button>
    <button id="dedupe" class="btn" type="button">Dedupe</button>
    <button id="rebuild" class="btn" type="button">Rebuild Index</button>
  </div>
  <div id="ingestAlerts" role="alert" style="display:none;padding:1rem;border-radius:10px;margin:1rem 0;font-weight:500"></div>
  <h3>Upload files (.vtt .srt .txt .pdf .docx .md)</h3>
  <div id="dropZone" style="border:2px dashed #ccc;border-radius:8px;padding:2rem;text-align:center;margin:1rem 0;cursor:pointer;background:#fafafa">
    <p>Drag and drop files here or click to select</p>
    <input id="files" type="file" multiple style="display:none"/>
  </div>
  <div id="fileList" style="margin:1rem 0"></div>
  <div id="uploadProgress" style="display:none;margin:1rem 0">
    <div style="background:#eee;border-radius:4px;height:20px;overflow:hidden">
      <div id="progressBar" style="background:#111;height:100%;width:0%;transition:width 0.3s"></div>
    </div>
    <div id="progressText" class="small" style="margin-top:0.5rem"></div>
  </div>
  <button id="upload" class="btn" type="button">Upload & Ingest</button>
  <button id="retryFilesBtn" class="btn" type="button" style="display:none;background:#0f766e;margin-left:0.75rem">Retry failed files</button>
  <div id="statusMessage" style="display:none;padding:1rem;border-radius:8px;margin:1rem 0;font-weight:500"></div>
  <h3>Ingestion History</h3>
  <div id="ingestHistory" style="max-height:200px;overflow:auto;margin:1rem 0">
    <p class="small" style="color:#666">No ingestion history yet.</p>
  </div>
  <h3>Log</h3>
  <pre id="log"></pre>
</section>

<section id="admin">
  <h2 style="margin-top:0">Admin</h2>
  <p class="small">Workspace billing and quota controls will live here. Until then, use the billing endpoints or CLI helpers.</p>
  <div class="empty-state">Admin dashboard coming soon.</div>
</section>

<div id="toast" role="status" aria-live="polite"></div>
  </main>
</div>

<script>
function $(id){return document.getElementById(id)}
const q=$("q"), ans=$("ans"), score=$("score"), mic=$("mic"), countEl=$("count"), log=$("log");
const navLinks=document.querySelectorAll('[data-nav]');
const sections=document.querySelectorAll('section');
const breadcrumb=$("breadcrumb");
const pageTitle=$("pageTitle");
const mainContent=$("mainContent");
const workspaceSelect=$("workspaceSelect");
const workspaceLabel=$("workspaceLabel");
const toast=$("toast");
const ingestAlerts=$("ingestAlerts");
const retryUrlsBtn=$("retryUrlsBtn");
const retryFilesBtn=$("retryFilesBtn");
const metricDocCount=$("metricDocCount");
const metricLastIngest=$("metricLastIngest");
const metricLastIngestDetail=$("metricLastIngestDetail");
const metricBillingStatus=$("metricBillingStatus");
const metricBillingDetail=$("metricBillingDetail");
let activeSection="ask";
let modalCleanup=null;
let failedUrls=[];
let failedFiles=[];

const breadcrumbMap={
  ask:["Home","Ask"],
  browser:["Home","Sources"],
  ingest:["Home","Ingest"],
  admin:["Home","Admin"],
};

function updateBreadcrumb(section, extraTrail){
  const base=breadcrumbMap[section] || ["Home"];
  const trail=extraTrail ? base.concat(extraTrail) : base;
  breadcrumb.innerHTML=trail.map((label,idx)=>`<span aria-current="${idx===trail.length-1?'page':'false'}">${label}</span>`).join("");
  if(pageTitle){
    pageTitle.textContent=trail[trail.length-1] || "Dashboard";
  }
}

function setActiveSection(id){
  activeSection=id;
  sections.forEach(sec=>sec.classList.toggle("active", sec.id===id));
  navLinks.forEach(link=>{
    const isActive=link.dataset.nav===id;
    link.classList.toggle("active", isActive);
    if(isActive){link.setAttribute("aria-current","page");}
    else{link.removeAttribute("aria-current");}
  });
  updateBreadcrumb(id);
  history.replaceState(null,"",`#${id}`);
  if(id==="browser"){ loadSources(); }
  if(mainContent){ mainContent.focus({preventScroll:false}); }
}

navLinks.forEach(link=>{
  link.addEventListener("click",e=>{
    e.preventDefault();
    const target=link.dataset.nav;
    if(target) setActiveSection(target);
  });
});

if(retryUrlsBtn){
  retryUrlsBtn.addEventListener("click",()=>{
    if(!failedUrls.length){
      retryUrlsBtn.style.display="none";
      return;
    }
    const urlsField = $("urls");
    if(urlsField){
      urlsField.value = failedUrls.join('\n');
      urlsField.focus();
    }
    retryUrlsBtn.style.display="none";
    showToast(`Prepared ${failedUrls.length} URL(s) for retry`);
    failedUrls = [];
  });
}

function showToast(message,type="success"){
  toast.textContent=message;
  toast.classList.remove("error","success");
  toast.classList.add(type==="error"?"error":"success");
  toast.style.display="block";
  clearTimeout(showToast._timer);
  showToast._timer=setTimeout(()=>toast.style.display="none",4000);
}

function setIngestAlert(message, tone="info"){
  if(!ingestAlerts) return;
  const palette = tone === "error"
    ? {bg:"#fef2f2", border:"#fecaca", color:"#7f1d1d"}
    : tone === "warning"
      ? {bg:"#fffbeb", border:"#fde68a", color:"#92400e"}
      : {bg:"#f1f5f9", border:"#cbd5f5", color:"#1e293b"};
  ingestAlerts.style.display = "block";
  ingestAlerts.style.background = palette.bg;
  ingestAlerts.style.border = `1px solid ${palette.border}`;
  ingestAlerts.style.color = palette.color;
  ingestAlerts.textContent = message;
}

function clearIngestAlert(){
  if(!ingestAlerts) return;
  ingestAlerts.style.display="none";
  ingestAlerts.textContent="";
}

function refreshLastIngestCard(){
  if(!metricLastIngest || !metricLastIngestDetail){ return; }
  if(!historyItems.length){
    metricLastIngest.textContent = "No ingests yet";
    metricLastIngestDetail.textContent = "Run ingest to populate your knowledge base.";
    return;
  }
  const last = historyItems[historyItems.length - 1];
  const when = new Date(last.timestamp);
  const formatted = when.toLocaleString();
  metricLastIngest.textContent = `${last.type === "url" ? "URL batch" : "File upload"}`;
  metricLastIngestDetail.textContent = `${formatted} ‚Ä¢ ${last.chunks || 0} chunks`;
}

async function refreshBillingStatus(){
  if(!metricBillingStatus || !metricBillingDetail){ return; }
  try{
    const resp = await fetch("/api/v1/admin/billing");
    if(!resp.ok){
      if(resp.status === 401 || resp.status === 403){
        metricBillingStatus.textContent = "Restricted";
        metricBillingDetail.textContent = "Sign in with admin access to view Stripe status.";
      }else if(resp.status === 503){
        metricBillingStatus.textContent = "Disabled";
        metricBillingDetail.textContent = "Stripe not configured. Set STRIPE_API_KEY to enable billing.";
      }else{
        metricBillingStatus.textContent = "Unknown";
        metricBillingDetail.textContent = `Billing endpoint returned ${resp.status}`;
      }
      return;
    }
    const data = await resp.json();
    const org = Array.isArray(data) ? data[0] : null;
    if(org){
      const status = (org.billing_status || "unknown").replace(/_/g, " ");
      metricBillingStatus.textContent = status;
      if(org.subscription_expires_at){
        metricBillingDetail.textContent = `Renews ${new Date(org.subscription_expires_at).toLocaleDateString()}`;
      }else if(org.trial_ends_at){
        metricBillingDetail.textContent = `Trial ends ${new Date(org.trial_ends_at).toLocaleDateString()}`;
      }else{
        metricBillingDetail.textContent = "No renewal date on file.";
      }
    }else{
      metricBillingStatus.textContent = "Pending";
      metricBillingDetail.textContent = "No organizations returned.";
    }
  }catch(e){
    metricBillingStatus.textContent = "Unknown";
    metricBillingDetail.textContent = e.message || "Unable to fetch billing status.";
  }
}

async function refreshStatsCard(){
  if(!metricDocCount){ return; }
  try{
    const r=await fetch("/api/v1/stats");
    if(!r.ok){
      metricDocCount.textContent = "‚Äì";
      return;
    }
    const d=await r.json();
    metricDocCount.textContent = d.count ?? "0";
  }catch(e){
    metricDocCount.textContent = "‚Äì";
  }
}

async function loadWorkspaces(){
  if(!workspaceSelect) return;
  try{
    const r=await fetch("/api/v1/admin/workspaces");
    if(!r.ok) throw new Error("Failed to load workspaces");
    const d=await r.json();
    const workspaces=d.workspaces || [];
    workspaceSelect.innerHTML = "";
    if(workspaces.length === 0){
      workspaceSelect.innerHTML = '<option value="default">Default workspace</option>';
    } else {
      workspaces.forEach(ws => {
        const opt = document.createElement("option");
        opt.value = ws.id;
        opt.textContent = ws.name;
        workspaceSelect.appendChild(opt);
      });
    }
    const storedWorkspace=localStorage.getItem("activeWorkspace");
    if(storedWorkspace && Array.from(workspaceSelect.options).some(o => o.value === storedWorkspace)){
      workspaceSelect.value=storedWorkspace;
    }
    if(workspaceLabel){
      const selected=workspaceSelect.options[workspaceSelect.selectedIndex];
      workspaceLabel.textContent=selected?.text || workspaceSelect.value;
    }
  }catch(e){
    console.warn("Workspace load failed, using defaults:", e);
    workspaceSelect.innerHTML = '<option value="default">Default workspace</option>';
  }
}
if(workspaceSelect){
  workspaceSelect.addEventListener("change",()=>{
    const selected=workspaceSelect.options[workspaceSelect.selectedIndex];
    localStorage.setItem("activeWorkspace", workspaceSelect.value);
    if(workspaceLabel){
      workspaceLabel.textContent=selected?.text || workspaceSelect.value;
    }
    showToast(`Workspace set to ${selected?.text || workspaceSelect.value}`);
  });
  loadWorkspaces();
}

function highlightText(text, query){
  if(!query || !text) return text;
  const words = query.toLowerCase().split(/\s+/).filter(w => w.length > 2);
  let highlighted = text;
  words.forEach(word => {
    const regex = new RegExp(`(${word})`, 'gi');
    highlighted = highlighted.replace(regex, '<mark style="background:#ffeb3b;padding:0 2px">$1</mark>');
  });
  return highlighted;
}

$("askBtn").onclick=async()=>{
  const query = q.value||"";
  if(!query.trim()){alert("Enter a question first"); return;}
  const f=new FormData(); f.append("query", query); f.append("k","8");
  ans.textContent = "";
  score.innerHTML = "";
  $("chunksSection").style.display = "none";
  const status=$("askStatus");
  status.style.display="block";
  $("askBtn").disabled=true;
  $("askBtn").textContent="Searching‚Ä¶";
  try{
    const r=await fetch("/ask",{method:"POST",body:f}); const d=await r.json();
    ans.textContent=d.answer||""; 
    const s=d.score||{};
    score.innerHTML=['coverage','groundedness','citations','brevity','total'].map(k=>`<span class="badge">${k}: ${s[k]??'-'}</span>`).join(' ');
    
    // Display chunks
    if(d.chunks && d.chunks.length > 0){
      $("chunksSection").style.display = "block";
      $("chunksCount").textContent = `(${d.chunks.length} chunks)`;
      $("chunksList").innerHTML = d.chunks.map((chunk, idx) => {
        const meta = chunk.metadata || {};
        const source = chunk.source || {};
        const isExpanded = idx < 3; // First 3 expanded by default
        return `
          <div class="chunk-card" style="border:1px solid #ddd;border-radius:8px;padding:1rem;margin-bottom:1rem">
            <div style="display:flex;justify-content:space-between;align-items:start;margin-bottom:0.5rem">
              <div>
                <strong>Chunk ${chunk.index}</strong>
                <span class="badge" style="margin-left:0.5rem">Score: ${chunk.score.toFixed(2)}</span>
                ${meta.start_sec !== undefined ? `<span class="badge">Time: ${Math.floor(meta.start_sec/60)}:${String(Math.floor(meta.start_sec%60)).padStart(2,'0')}</span>` : ''}
                ${meta.chunk_index !== undefined ? `<span class="badge">Part ${meta.chunk_index + 1}/${meta.chunk_count || ''}</span>` : ''}
              </div>
              <button class="btn" onclick="toggleChunk(${idx})" style="padding:0.4rem 0.8rem;font-size:0.9em" id="toggleBtn${idx}">
                ${isExpanded ? 'Collapse' : 'Expand'}
              </button>
            </div>
            <div class="small" style="color:#666;margin-bottom:0.5rem">
              Source: ${source.type || 'unknown'} | 
              <a href="${chunk.citation}" target="_blank">${chunk.citation}</a>
            </div>
            <div id="chunkContent${idx}" style="${isExpanded ? '' : 'display:none'}">
              <div style="white-space:pre-wrap;background:#f7f7f7;padding:1rem;border-radius:4px;max-height:300px;overflow:auto">
                ${highlightText((chunk.content || '').replace(/</g,'&lt;').replace(/>/g,'&gt;'), query)}
              </div>
            </div>
          </div>
        `;
      }).join('');
      window.chunksData = d.chunks;
    }else{
      $("chunksSection").style.display="none";
      $("chunksList").innerHTML = `<div class="empty-state">No supporting chunks found yet.</div>`;
    }
  }catch(e){
    ans.textContent = `Error: ${e.message||'Request failed'}`;
  }finally{
    $("askBtn").disabled=false;
    $("askBtn").textContent="Ask";
    status.style.display="none";
  }
};

function toggleChunk(idx){
  const content = $("chunkContent"+idx);
  const btn = $("toggleBtn"+idx);
  if(content.style.display === "none"){
    content.style.display = "block";
    btn.textContent = "Collapse";
  }else{
    content.style.display = "none";
    btn.textContent = "Expand";
  }
}
window.toggleChunk = toggleChunk;

$("ingestUrls").onclick=async()=>{
  const urls = $("urls").value||"";
  if(!urls.trim()){alert("Enter URLs first"); return;}
  const f=new FormData(); f.append("urls", urls);
  log.textContent="Ingesting‚Ä¶";
  uploadProgress.style.display = "block";
  progressBar.style.width = "50%";
  progressText.textContent = "Processing URLs...";
  clearIngestAlert();
  failedUrls = [];
  if(retryUrlsBtn){ retryUrlsBtn.style.display="none"; }
  
  try{
    const response=await fetch("/ingest/urls",{method:"POST",body:f});
    const status=response.status;
    const d=await response.json();
    if(status === 402){
      showStatus(d.detail || "Billing inactive. Enable a subscription to ingest new content.", "error");
      progressText.textContent = "Billing required";
      uploadProgress.style.display="none";
      progressBar.style.width = "0%";
      return;
    }
    if(status === 429){
      showStatus(d.detail || "Workspace quota exceeded. Try again after usage resets.", "error");
      uploadProgress.style.display="none";
      progressBar.style.width = "0%";
      return;
    }
    progressBar.style.width = "100%";
    log.textContent=JSON.stringify(d,null,2);

    if(d.queued){
      const partial = d.partial_results || [];
      if(partial.length){
        const errors = partial.filter(item => item.error).map(item => `${item.url || ''}: ${item.error}`).filter(Boolean);
        if(errors.length){
          showStatus(`‚è≥ Job queued (${d.job_id}). ${errors.length} URL(s) need attention before processing finishes.`, "error");
        } else {
          showStatus(`‚è≥ Job queued (${d.job_id}). Processing in background.`, "success");
        }
      } else {
        showStatus(`‚è≥ Job queued (${d.job_id}). Processing in background.`, "success");
      }
      progressText.textContent = "Queued for background processing";
      setTimeout(() => {
        uploadProgress.style.display = "none";
        progressBar.style.width = "0%";
      }, 3000);
      return;
    }

    let successCount = 0;
    let errorCount = 0;
    let totalChunks = 0;
    const errors = [];

    (d.results || []).forEach(result => {
      if(result.error){
        errorCount++;
        errors.push(`${result.url}: ${result.error}`);
        if(result.url){ failedUrls.push(result.url); }
      } else if(result.written > 0){
        successCount++;
        totalChunks += result.written || 0;
      } else {
        errorCount++;
        errors.push(`${result.url}: No chunks written (video may not have transcripts)`);
        if(result.url){ failedUrls.push(result.url); }
      }
      historyItems.push({
        type: "url",
        url: result.url,
        chunks: result.written || 0,
        timestamp: new Date().toISOString()
      });
    });

    if(successCount > 0 && errorCount === 0){
      showStatus(`‚úÖ Success! Ingested ${totalChunks} chunks from ${successCount} URL(s)`, "success");
      progressText.textContent = `Success! ${totalChunks} chunks ingested`;
    } else if(successCount > 0 && errorCount > 0){
      showStatus(`‚ö†Ô∏è Partial success: ${totalChunks} chunks from ${successCount} URL(s), ${errorCount} failed. Check log for details.`, "error");
      progressText.textContent = `Partial: ${totalChunks} chunks, ${errorCount} failed`;
    } else {
      const errorMsg = errors.length > 0 ? errors[0] : (d.detail || "No chunks were written");
      showStatus(`‚ùå Failed: ${errorMsg}`, "error");
      progressText.textContent = "Failed - see details below";
    }

    if(countEl) countEl.textContent = d.count || 0;
    localStorage.setItem('ingestHistory', JSON.stringify(historyItems));
    updateHistory();
    await refreshStatsCard();
    
    if(failedUrls.length && retryUrlsBtn){
      retryUrlsBtn.style.display="inline-block";
    }
    
    setTimeout(() => {
      uploadProgress.style.display = "none";
      progressBar.style.width = "0%";
    }, 5000);
  }catch(e){
    progressText.textContent = `Error: ${e.message}`;
    log.textContent = `Error: ${e.message}`;
    showStatus(`‚ùå Error: ${e.message}`, "error");
  }
};

// Drag and drop
const dropZone = $("dropZone");
const fileInput = $("files");
const fileList = $("fileList");
const uploadProgress = $("uploadProgress");
const progressBar = $("progressBar");
const progressText = $("progressText");
const ingestHistory = $("ingestHistory");
const statusMessage = $("statusMessage");

if(retryFilesBtn){
  retryFilesBtn.addEventListener("click",()=>{
    if(!failedFiles.length){
      retryFilesBtn.style.display="none";
      return;
    }
    const dt = new DataTransfer();
    failedFiles.forEach(file=>dt.items.add(file));
    fileInput.files = dt.files;
    updateFileList();
    showToast(`Ready to retry ${failedFiles.length} file(s). Click Upload when ready.`);
    retryFilesBtn.style.display="none";
    failedFiles = [];
  });
}

function showStatus(message, type="success"){
  statusMessage.style.display = "block";
  statusMessage.textContent = message;
  statusMessage.style.background = type === "success" ? "#d4edda" : "#f8d7da";
  statusMessage.style.color = type === "success" ? "#155724" : "#721c24";
  statusMessage.style.border = `1px solid ${type === "success" ? "#c3e6cb" : "#f5c6cb"}`;
  setIngestAlert(message, type === "success" ? "info" : "error");
  showToast(message, type === "success" ? "success" : "error");
  setTimeout(() => {
    statusMessage.style.display = "none";
    if(type === "success"){ clearIngestAlert(); }
  }, 10000);
}

dropZone.onclick = () => fileInput.click();
dropZone.ondragover = (e) => { e.preventDefault(); dropZone.style.borderColor = "#111"; };
dropZone.ondragleave = () => { dropZone.style.borderColor = "#ccc"; };
dropZone.ondrop = (e) => {
  e.preventDefault();
  dropZone.style.borderColor = "#ccc";
  fileInput.files = e.dataTransfer.files;
  updateFileList();
};

fileInput.onchange = updateFileList;
function updateFileList(){
  const files = Array.from(fileInput.files || []);
  if(files.length === 0){
    fileList.innerHTML = "";
    return;
  }
  fileList.innerHTML = `<div class="small" style="margin-bottom:0.5rem">Selected ${files.length} file(s):</div>` +
    files.map(f => `<div class="small" style="padding:0.25rem">${f.name} (${(f.size/1024).toFixed(1)} KB)</div>`).join('');
}

let historyItems = JSON.parse(localStorage.getItem('ingestHistory') || '[]');
function updateHistory(){
  if(historyItems.length === 0){
    ingestHistory.innerHTML = '<p class="small" style="color:#666">No ingestion history yet.</p>';
  }else{
    ingestHistory.innerHTML = historyItems.slice(-10).reverse().map(item => `
    <div style="border-bottom:1px solid #eee;padding:0.5rem 0;font-size:0.9em">
      <strong>${item.type}</strong>: ${item.name || item.url || 'Unknown'}
      <div class="small" style="color:#666">${new Date(item.timestamp).toLocaleString()} | ${item.chunks || 0} chunks</div>
    </div>
  `).join('');
  }
  refreshLastIngestCard();
}
updateHistory();

$("upload").onclick=async()=>{
  const fs=fileInput.files; if(!fs.length){alert("Select files first"); return;}
  const f=new FormData(); for(const x of fs){ f.append("files",x); }
  log.textContent="Uploading‚Ä¶";
  uploadProgress.style.display = "block";
  progressBar.style.width = "30%";
  progressText.textContent = "Uploading files...";
  clearIngestAlert();
  failedFiles = [];
  if(retryFilesBtn){ retryFilesBtn.style.display="none"; }
  
  try{
    const response=await fetch("/ingest/files",{method:"POST",body:f});
    const status=response.status;
    const d=await response.json();
    if(status === 402){
      showStatus(d.detail || "Billing inactive. Enable a subscription to ingest new content.", "error");
      progressText.textContent = "Billing required";
      uploadProgress.style.display="none";
      progressBar.style.width = "0%";
      return;
    }
    if(status === 429){
      showStatus(d.detail || "Workspace quota exceeded. Try again later.", "error");
      uploadProgress.style.display="none";
      progressBar.style.width = "0%";
      return;
    }
    progressBar.style.width = "70%";
    progressText.textContent = "Processing...";
    log.textContent=JSON.stringify(d,null,2);
    progressBar.style.width = "100%";

    if(d.queued){
      const partial = d.partial_results || [];
      if(partial.length){
        const partialErrors = partial.filter(item => item.error);
        if(partialErrors.length){
          showStatus(`‚è≥ Job queued (${d.job_id}). ${partialErrors.length} file(s) reported issues before queueing.`, "error");
        } else {
          showStatus(`‚è≥ Job queued (${d.job_id}). Files will process in the background.`, "success");
        }
      } else {
        showStatus(`‚è≥ Job queued (${d.job_id}). Files will process in the background.`, "success");
      }
      progressText.textContent = "Queued for background processing";
      setTimeout(() => {
        uploadProgress.style.display = "none";
        progressBar.style.width = "0%";
      }, 3000);
      return;
    }

    let successCount = 0;
    let errorCount = 0;
    let totalChunks = 0;
    const errors = [];

    Array.from(fs).forEach((file, idx) => {
      const result = d.results?.[idx] || {};
      if(result.error){
        errorCount++;
        errors.push(`${file.name}: ${result.error}`);
        failedFiles.push(file);
      } else if(result.written > 0){
        successCount++;
        totalChunks += result.written || 0;
      } else {
        errorCount++;
        errors.push(`${file.name}: No chunks written`);
        failedFiles.push(file);
      }
      historyItems.push({
        type: "file",
        name: file.name,
        chunks: result.written || 0,
        timestamp: new Date().toISOString()
      });
    });

    if(successCount > 0 && errorCount === 0){
      showStatus(`‚úÖ Success! Ingested ${totalChunks} chunks from ${successCount} file(s)`, "success");
      progressText.textContent = `Success! ${totalChunks} chunks ingested`;
    } else if(successCount > 0 && errorCount > 0){
      showStatus(`‚ö†Ô∏è Partial success: ${totalChunks} chunks from ${successCount} file(s), ${errorCount} failed. Check log for details.`, "error");
      progressText.textContent = `Partial: ${totalChunks} chunks, ${errorCount} failed`;
    } else {
      const errorMsg = errors.length > 0 ? errors[0] : (d.detail || "No chunks were written");
      showStatus(`‚ùå Failed: ${errorMsg}`, "error");
      progressText.textContent = "Failed - see details below";
    }

    if(countEl) countEl.textContent = d.count || 0;
    localStorage.setItem('ingestHistory', JSON.stringify(historyItems));
    updateHistory();
    await refreshStatsCard();

    if(failedFiles.length && retryFilesBtn){
      const dt = new DataTransfer();
      failedFiles.forEach(file=>dt.items.add(file));
      fileInput.files = dt.files;
      updateFileList();
      retryFilesBtn.style.display="inline-block";
    } else {
      setTimeout(() => {
        fileInput.value = "";
        updateFileList();
      }, 500);
    }
    
    setTimeout(() => {
      uploadProgress.style.display = "none";
      progressBar.style.width = "0%";
    }, 5000);
  }catch(e){
    progressText.textContent = `Error: ${e.message}`;
    log.textContent = `Error: ${e.message}`;
    showStatus(`‚ùå Error: ${e.message}`, "error");
  }
};

$("dedupe").onclick=async()=>{
  log.textContent="Deduping‚Ä¶";
  try{
    const r=await fetch("/dedupe",{method:"POST"}); const d=await r.json();
    log.textContent=JSON.stringify(d,null,2);
    if(countEl) countEl.textContent = d.count || 0;
  }catch(e){
    log.textContent = `Error: ${e.message}`;
  }
};

$("rebuild").onclick=async()=>{
  log.textContent="Rebuilding index‚Ä¶";
  try{
    const r=await fetch("/rebuild",{method:"POST"}); const d=await r.json();
    log.textContent=JSON.stringify(d,null,2);
    if(countEl) countEl.textContent = d.count || 0;
  }catch(e){
    log.textContent = `Error: ${e.message}`;
  }
};

// Speech-to-text
let rec=null,on=false;
mic.onclick=()=>{ const SR=window.SpeechRecognition||window.webkitSpeechRecognition; if(!SR){alert("SpeechRecognition not available in this browser"); return;}
  if(!rec){rec=new SR(); rec.lang='en-US'; rec.continuous=true; rec.onresult=(e)=>{let t=''; for(let i=0;i<e.results.length;i++){t+=e.results[i][0].transcript+' ';} q.value=t.trim();}; rec.onend=()=>{on=false; mic.textContent='üé§ Start listening';}; }
  if(!on){rec.start(); on=true; mic.textContent='üõë Stop listening';} else {rec.stop();}
};

// Browser functionality
let allSources = [];
async function loadSources(){
  try{
    const r=await fetch("/api/v1/sources"); const d=await r.json();
    allSources = d.sources || [];
    renderSources();
  }catch(e){
    $("sourcesList").innerHTML=`<p style="color:red">Error loading sources: ${e.message}</p>`;
  }
}
function renderSources(){
  const filter = ($("sourceFilter")?.value || "").toLowerCase();
  const filtered = allSources.filter(s => 
    !filter || 
    (s.display_name || "").toLowerCase().includes(filter) ||
    (s.type || "").toLowerCase().includes(filter) ||
    (s.path || "").toLowerCase().includes(filter) ||
    (s.url || "").toLowerCase().includes(filter)
  );
  if(filtered.length === 0){
    $("sourcesList").innerHTML = `<div class="empty-state">No sources found${filter ? ' matching filter' : ''}.</div>`;
    return;
  }
  $("sourcesList").innerHTML = filtered.map(s => `
    <div class="source-card" style="border:1px solid #ddd;border-radius:8px;padding:1rem;margin-bottom:1rem">
      <div style="display:flex;justify-content:space-between;align-items:start;margin-bottom:0.5rem">
        <div style="flex:1">
          <strong>${s.display_name || 'Unknown'}</strong>
          <div class="small" style="margin-top:0.25rem">
            <span class="badge">${s.type}</span>
            <span class="badge">${s.chunk_count} chunks</span>
            ${s.language ? `<span class="badge">${s.language}</span>` : ''}
          </div>
        </div>
        <div style="display:flex;gap:0.5rem">
          <button class="btn" onclick="viewSource('${s.id}')" style="padding:0.4rem 0.8rem;font-size:0.9em">View</button>
          <button class="btn" onclick="deleteSource('${s.id}')" style="padding:0.4rem 0.8rem;font-size:0.9em;background:#c33">Delete</button>
        </div>
      </div>
      <div class="small" style="color:#666">
        ${s.path ? `Path: ${s.path}<br>` : ''}
        ${s.url ? `URL: <a href="${s.url}" target="_blank">${s.url}</a><br>` : ''}
        ${s.first_seen ? `Added: ${new Date(s.first_seen).toLocaleString()}` : ''}
      </div>
    </div>
  `).join('');
}
$("sourceFilter").oninput = renderSources;
$("refreshSources").onclick = loadSources;
async function viewSource(id){
  try{
    const r=await fetch(`/api/v1/sources/${id}/chunks`); const d=await r.json();
    const chunks = d.chunks || [];
    const modal = document.createElement('div');
    modal.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.7);z-index:1000;overflow:auto;padding:2rem';
    modal.innerHTML = `
      <div role="dialog" aria-modal="true" style="background:white;max-width:800px;margin:0 auto;padding:2rem;border-radius:12px;position:relative">
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:1rem">
          <h2>Document Viewer</h2>
          <button id="modalCloseBtn" class="btn" type="button">Back to sources</button>
        </div>
        <div style="max-height:70vh;overflow:auto">
          ${chunks.map((c,idx) => `
            <div style="border-bottom:1px solid #eee;padding:1rem 0">
              <div class="small" style="color:#666;margin-bottom:0.5rem">
                Chunk ${idx+1} of ${chunks.length}
                ${c.metadata?.start_sec !== undefined ? ` | Time: ${Math.floor(c.metadata.start_sec/60)}:${String(Math.floor(c.metadata.start_sec%60)).padStart(2,'0')}` : ''}
              </div>
              <div style="white-space:pre-wrap">${(c.content || '').replace(/</g,'&lt;').replace(/>/g,'&gt;')}</div>
            </div>
          `).join('')}
        </div>
      </div>
    `;
    document.body.appendChild(modal);
    updateBreadcrumb('browser',['Chunk Preview']);
    let lastFocused=document.activeElement;
    const closeModal=()=>{
      document.removeEventListener('keydown', escHandler);
      modal.remove();
      updateBreadcrumb(activeSection);
      const list=$("sourcesList");
      if(list){ list.scrollIntoView({behavior:'smooth'}); list.focus?.(); }
      if(lastFocused){ lastFocused.focus?.(); }
      modalCleanup=null;
    };
    const escHandler=(evt)=>{ if(evt.key==="Escape"){ closeModal(); } };
    modalCleanup=closeModal;
    document.getElementById('modalCloseBtn').onclick=closeModal;
    document.addEventListener('keydown',escHandler);
  }catch(e){
    alert(`Error loading source: ${e.message}`);
  }
}
async function deleteSource(id){
  if(!confirm('Delete this source and all its chunks?')) return;
  try{
    const r=await fetch(`/api/v1/sources/${id}`,{method:'DELETE'}); const d=await r.json();
    await loadSources();
    if(countEl) countEl.textContent = d.kept || 0;
    alert(`Deleted ${d.deleted || 0} chunks. ${d.kept || 0} chunks remaining.`);
  }catch(e){
    alert(`Error deleting source: ${e.message}`);
  }
}
window.viewSource = viewSource;
window.deleteSource = deleteSource;
window.addEventListener('keydown', (evt)=>{
  if(evt.key==="Escape" && modalCleanup){
    modalCleanup();
  }
});

document.addEventListener('keydown',(evt)=>{
  const meta = evt.metaKey || evt.ctrlKey;
  if(meta && evt.key === 'Enter'){
    if(activeSection === 'ask'){
      evt.preventDefault();
      $("askBtn")?.click();
    }
  }
  if(meta && (evt.key === 'k' || evt.key === 'K')){
    evt.preventDefault();
    if(activeSection === 'browser'){
      $("sourceFilter")?.focus();
    }else{
      q?.focus();
    }
  }
});

window.addEventListener("DOMContentLoaded",()=>{
  const hash=(location.hash||"#ask").replace("#","");
  if(breadcrumbMap[hash]) setActiveSection(hash);
  else setActiveSection("ask");
});

// Authentication state
let currentUser = null;

async function checkAuth(){
  try{
    const r=await fetch("/auth/me"); const d=await r.json();
    const userInfo = $("userInfo");
    const loginBtn = $("loginBtn");
    const userName = $("userName");
    
    if(d.authenticated && d.user){
      currentUser = d.user;
      if(userInfo) userInfo.style.display = "flex";
      if(loginBtn) loginBtn.style.display = "none";
      if(userName) userName.textContent = d.user.name || d.user.email || "User";
    }else{
      currentUser = null;
      if(userInfo) userInfo.style.display = "none";
      if(loginBtn) loginBtn.style.display = "block";
    }
  }catch(e){
    console.error("Auth check failed:", e);
    currentUser = null;
    const userInfo = $("userInfo");
    const loginBtn = $("loginBtn");
    if(userInfo) userInfo.style.display = "none";
    if(loginBtn) loginBtn.style.display = "block";
  }
}

// Setup login/logout handlers
function setupAuthHandlers(){
  const loginBtn = $("loginBtn");
  if(loginBtn){
    loginBtn.onclick = () => {
      window.location.href = "/auth/google";
    };
  }
  const logoutBtn = $("logoutBtn");
  if(logoutBtn){
    logoutBtn.onclick = async () => {
      await fetch("/auth/logout");
      window.location.reload();
    };
  }
}

// Check for auth error in URL
if(window.location.search.includes("error=auth_failed")){
  alert("Authentication failed. Please try again.");
  window.history.replaceState({}, document.title, window.location.pathname);
}

// Load stats on page load
(async()=>{
  setupAuthHandlers();
  await checkAuth();
  await refreshStatsCard();
  await refreshBillingStatus();
  refreshLastIngestCard();
  try{
    const r=await fetch("/api/v1/stats"); const d=await r.json();
    if(countEl) countEl.textContent = d.count || 0;
  }catch(e){}
})();
</script>
</body>
</html>